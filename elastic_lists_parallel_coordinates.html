<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
  <head>
    <title>Protovis Elastic Lists</title>
    <script src="protovis-d3.2.js" type="text/javascript" charset="utf-8"></script>    
    <script src="cars.js" type="text/javascript" charset="utf-8"></script>    
  </head>
  <body>
    <div id="elastic_lists"> 
    <script type="text/javascript"> 
    
      // Todo: Animation (yeah right ;-)                                       
      // Todo: scrolling         
      // Todo: convert to layout/mark                                    
      // Todo: (done) Bug - select cylinders 3, then weight 2001 to 2500, then cylinders 3 - no snap-back 
      // Todo: (done) For efficiency, cache/memoize the histogram bins
    
      // Add duplicate removal to the array prototype - stolen from some blog
    
      if (!Array.prototype.remove_dups) Array.prototype.remove_dups = function(f, o) {
        var result = [];

        label:for(var i=0; i<this.length;i++ ) {  
          for(var j=0; j<this.length; j++) {
            if(result[j]==this[i]) 
            continue label;
          }
          
          result[result.length] = this[i];
        }
        
        return result;
      }
    
      var elastic_lists = function(cols, data, h, w, f, spacing, callback_vis) { 
        
        var cached_data = data;  
        var cached_bins = [];
        var data_stale = true;  
        var histos = [];
        var bins = []; 
        var orig_bins = [];           
        var bins_func = []; 
        var totals = [];
        var col_vals = [];
        var bin_vals = [];
        var col_selections = [];
        var bin_selections = [];
        var y = []; 
        var char_test = new RegExp("([A-Z]|[a-z])+");            

        var floory = function(y) {
          if(y > f) {
            return y;
          } else {
            return f;
          }
        }

        var total_height = function(a, b) {
          if(b.y == 0) {
            return a;
          } else {           
            return a + floory(b.y) + spacing;
          }
        }

        var filtered_data = function() {
          if(data_stale) {               
            var relevant_columns = [];

            relevant_columns = bin_selections.map(function(e,i) {

              // reduce on bin_vals and bin_selections to figure out if a column has a selection

              return bin_vals[i].reduce(function(a,b) {
                return a || e[b];
              },false);
            });                        

            cached_data = data.filter(function(e,i) {
              return relevant_columns.reduce(function(a,b,j) {
                if(b === true) {                                                                   
                  return a && col_selections[j][(e[cols[j]["name"]])];
                } else {
                  return a && true;
                }
              },true);         
            });                                        

            data_stale = false;

            return cached_data;
          } else {
            return cached_data;
          }
        }  

        // build arrays of all values for each column, sorted      
        cols.forEach(function(e,i){ 
          var temp_col = [];
          col_vals[i] = [];     

          // build selection map
          col_selections[i] = {};
          bin_selections[i] = {};
          
          data.forEach(function(f){
            temp_col.push(f[e["name"]]);
          });
          
          // Remove duplicates from column values.
          col_vals[i] = temp_col.remove_dups();                                                                        

          // use default sort or number sort, depending on if column contains a-z or A-Z characters
          if(char_test.test(col_vals[i].join())) {
            col_vals[i].sort();
          } else {
            col_vals[i].sort(function(a,b){
              return a-b;
            });
          }                                          
        });  
        
        // build arrays of values to use as bins, based on column value arrays
        col_vals.forEach(function(e,i){ 
          
          if(char_test.test(col_vals[i].join())) {
            bin_vals[i] = e;         
          } else {
            bin_vals[i] = pv.range(Math.round((col_vals[i].shift() - cols[i]["step"]) / cols[i]["step"]) * cols[i]["step"],
              Math.round((col_vals[i].pop() + cols[i]["step"]) / cols[i]["step"]) * cols[i]["step"],
              cols[i]["step"]); 
          }
        });   
        
        // Build histogram bins                        
        // Note: All the function junk in there is to memoize/cache based
        // on cols[i]["stale"] being true/false  
        
        cols.forEach(function(e,i){ 
          
          e["stale"] = true;  
          
          if(char_test.test(col_vals[i].join())) {
            
            // We redo the protovis histogram bin implementation to handle text-based values
            // with the same API as bins (minus .dx). 
                                          
            bins.push((function () {   
              var bs = [];
              
              var bin_func = function(){
                
                if(e["stale"]) {
                  
                  bs = [];
              
                  // Initialize bins                       
                  col_vals[i].forEach(function(a,j) {
                    var bin = bs[j] = [];
                    bin.x = a;
                    bin.dx = 1; 
                  
                    filtered_data().filter(function(b) {
                      return b[cols[i]["name"]] == a;
                    }).forEach(function(b) {
                      bin.push(b);
                    });        
                                
                    bin.y = bin.length;
                  });
                  
                  e["stale"] = false; 
                }  
              
                return bs;
              }; 
              
              return bin_func;
            }()));
          } else {
            bins.push((function () {   
              var bs = [];
              
              var bin_func = function() {
                if(e["stale"]) {
                  bs = pv.histogram(filtered_data(), function(d) { 
                    return d[e["name"]] })
                    .bins(bin_vals[i]).sort().reverse();
              
                  e["stale"] = false;
                }
              
                return bs;
              }; 
              
              return bin_func;
            }()));
          }
        });

        // build static cache of bin values for full data set
        cols.forEach(function(e,i) {
          orig_bins[i] = {};

          bins[i]().forEach(function(f) {
            function Bin(y,bins) {
              this.y = y;
              this.bins = bins;
            }      
              
            orig_bins[i][f.x] = new Bin(f.y, f)
          });                 
        }); 

        // calculate totals for each list visualization
        bins.forEach(function(e,i){
          totals.push(function() {
            return e().reduce(total_height,0) - spacing;
          });
        });

        // set up y-scales for each list visualization              
        totals.forEach(function(e){      
          y.push(function() {
            return pv.Scale.linear(0,e()).range(0,h);
          })
        });

        var outside_panel = new pv.Panel()
          .width((w + 10) * y.length + 10).height(h + 30).fillStyle("lightgrey")
          .canvas("elastic_lists");                    

        var list = outside_panel.add(pv.Panel)
          .data(bins) 
          .top(20)
          .left(function() {
            return 10 + ((w + 10) * this.index );
          })
          .width(w).height(h).fillStyle("lightgrey");
          
        // Column name labels

        list.anchor("top").add(pv.Label)
          .top(-15)     
          .font("bold 11px sans-serif")
          .text(function() {
            var full_label = cols[this.parent.index]["name"].toLowerCase();
            return full_label.substring(0,1).toUpperCase().concat(full_label.substring(1));
          });          

        var panel = list.add(pv.Panel)  
            .data(function(d){       
              return d();
            })                         
            .top(function() {              
              var sliced = bins[this.parent.index]().slice(0,this.index);
              var r = sliced.reduce(total_height, 0);
              return y[this.parent.index]()(r);
            })     
            .height(function(d) { 
              return y[this.parent.index]()(floory(d.y)) })
            .visible(function(d) { return !(d.y == 0);})

        var section = panel.add(pv.Bar)           
            .def("active", false)     
            .fillStyle(function(d) {
              return this.active() ? "orange" : bin_selections[this.parent.parent.index][d.x] ? "grey" : "steelblue"
            })
            .event("mouseover", function() { this.active(true); this.render() })
            .event("mouseout", function() { this.active(false); this.render() })
            .event("click", function(d) {                          
                           
              // Make sure we properly set a selection for each element in the bin.
              orig_bins[this.parent.parent.index][d.x].bins.forEach(function(b,i) { 
                col_selections[this.parent.parent.index][b[cols[this.parent.parent.index]["name"]]] = 
                  !bin_selections[this.parent.parent.index][d.x];  
              }, this);               

              // Make sure we have a selection that exactly matches the bin.          
              bin_selections[this.parent.parent.index][d.x] = !bin_selections[this.parent.parent.index][d.x];   
                                                                       
              this.active(false);
              data_stale = true;  
              
              cols.forEach(function(c) {
                c["stale"] = true;
              })                                                            
              
              list.render();  
                
              if(callback_vis) {
                callback_vis.render();
              };         
            });                                     

        section.anchor("left").add(pv.Label)
          .text(function(d) {
                        
            var value = d.x;
            
            if(!char_test.test(col_vals[this.parent.parent.index].join())) {
              value++;
            } 
            
            var range = "";

            if(cols[this.parent.parent.index]["step"] > 1) {
              range = " to " + (d.x + cols[this.parent.parent.index]["step"]);
            }

            var t = value.toString() + range;
            if( d.y > 0 ) { 
              return t; 
            }
          });

        section.anchor("right").add(pv.Label)
          .text(function(d) {                                
            return d.y + "/" + orig_bins[this.parent.parent.index][d.x].y;
          });                                                                        

        list.render();         
        
        return filtered_data;
      };
      
      // define columns for elastic lists (1 list per column)
      var cols = [
        {name: "cylinders", step: 1},
        {name: "year", step: 1},
        {name: "acceleration", step: 1},
        {name: "weight", step: 500},
        {name: "mpg", step: 1},
        {name: "name"}
        ]; 
                          
      var data = cars;                    
                              
    </script>
    </div>
    
    <div id="visualization">
    <script type="text/javascript">

  /* The dimensions to visualize, in order. */
  var dims = [
    "cylinders",
    "displacement",
    "weight",
    "horsepower",
    "acceleration",
    "mpg",
    "year",
    "origin"
  ];

  /* Sizing and scales. */
  var w = 840;
  var h = 420;
  var color = pv.Colors.category10();
  var x = pv.Scale.ordinal(dims).splitFlush(0, w);
              
  /* The root panel. */
  var vis = new pv.Panel()
      .width(w)
      .height(h)
      .margin(20)
      .bottom(40);   
      
  vis.canvas = "visualization";         

  /* Rule and labels per dimension. */
  var rule = vis.add(pv.Rule)
      .data(dims)
      .left(x)
      .strokeStyle(color.by(pv.index))
      .lineWidth(2);

  rule.anchor("top").add(pv.Label)
      .text(function(t) { return y[t].domain()[0] });

  rule.anchor("bottom").add(pv.Label)
      .text(function(t) { return y[t].domain()[1] });

  rule.anchor("bottom").add(pv.Label)
      .textStyle(function() { return color(this.index).darker() })
      .textMargin(14);
      
  var filtered_data = elastic_lists(cols, data, 350, 150, 20, 1, vis);  
                                 
  var y = pv.dict(dims, function(t) { return pv.Scale.linear()
    .domain(filtered_data().filter(function(d) { return !isNaN(d[t]) }), function(d) { return d[t] })
    .range(0, h) });

  /* Parallel coordinates. */
  vis.add(pv.Panel)
      .data(filtered_data)
    .add(pv.Line)
      .data(dims)
      .left(function(t, d) { return x(t) })
      .bottom(function(t, d) { return y[t](d[t]) })
      .strokeStyle("rgba(0, 0, 0, .2)")
      .lineWidth(1);
      
  vis.render();

      </script> 
      </div>
  </body>
</html>